"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printSecurityDiff = exports.RequireApproval = exports.printStackDiff = void 0;
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const logging_1 = require("./logging");
/**
 * Pretty-prints the differences between two template states to the console.
 *
 * @param oldTemplate the old/current state of the stack.
 * @param newTemplate the new/target state of the stack.
 * @param strict      do not filter out AWS::CDK::Metadata
 * @param context     lines of context to use in arbitrary JSON diff
 *
 * @returns the count of differences that were rendered.
 */
function printStackDiff(oldTemplate, newTemplate, strict, context, stream) {
    let diff = cfnDiff.diffTemplate(oldTemplate, newTemplate.template);
    // detect and filter out mangled characters from the diff
    let filteredChangesCount = 0;
    if (diff.differenceCount && !strict) {
        const mangledNewTemplate = JSON.parse(cfnDiff.mangleLikeCloudFormation(JSON.stringify(newTemplate.template)));
        const mangledDiff = cfnDiff.diffTemplate(oldTemplate, mangledNewTemplate);
        filteredChangesCount = Math.max(0, diff.differenceCount - mangledDiff.differenceCount);
        if (filteredChangesCount > 0) {
            diff = mangledDiff;
        }
    }
    // filter out 'AWS::CDK::Metadata' resources from the template
    if (diff.resources && !strict) {
        diff.resources = diff.resources.filter(change => {
            if (!change) {
                return true;
            }
            if (change.newResourceType === 'AWS::CDK::Metadata') {
                return false;
            }
            if (change.oldResourceType === 'AWS::CDK::Metadata') {
                return false;
            }
            return true;
        });
    }
    if (!diff.isEmpty) {
        cfnDiff.formatDifferences(stream || process.stderr, diff, {
            ...logicalIdMapFromTemplate(oldTemplate),
            ...buildLogicalToPathMap(newTemplate),
        }, context);
    }
    else {
        (0, logging_1.print)(chalk.green('There were no differences'));
    }
    if (filteredChangesCount > 0) {
        (0, logging_1.print)(chalk.yellow(`Omitted ${filteredChangesCount} changes because they are likely mangled non-ASCII characters. Use --strict to print them.`));
    }
    return diff.differenceCount;
}
exports.printStackDiff = printStackDiff;
var RequireApproval;
(function (RequireApproval) {
    RequireApproval["Never"] = "never";
    RequireApproval["AnyChange"] = "any-change";
    RequireApproval["Broadening"] = "broadening";
})(RequireApproval || (exports.RequireApproval = RequireApproval = {}));
/**
 * Print the security changes of this diff, if the change is impactful enough according to the approval level
 *
 * Returns true if the changes are prompt-worthy, false otherwise.
 */
function printSecurityDiff(oldTemplate, newTemplate, requireApproval) {
    const diff = cfnDiff.diffTemplate(oldTemplate, newTemplate.template);
    if (difRequiresApproval(diff, requireApproval)) {
        // eslint-disable-next-line max-len
        (0, logging_1.warning)(`This deployment will make potentially sensitive changes according to your current security approval level (--require-approval ${requireApproval}).`);
        (0, logging_1.warning)('Please confirm you intend to make the following modifications:\n');
        cfnDiff.formatSecurityChanges(process.stdout, diff, buildLogicalToPathMap(newTemplate));
        return true;
    }
    return false;
}
exports.printSecurityDiff = printSecurityDiff;
/**
 * Return whether the diff has security-impacting changes that need confirmation
 *
 * TODO: Filter the security impact determination based off of an enum that allows
 * us to pick minimum "severities" to alert on.
 */
function difRequiresApproval(diff, requireApproval) {
    switch (requireApproval) {
        case RequireApproval.Never: return false;
        case RequireApproval.AnyChange: return diff.permissionsAnyChanges;
        case RequireApproval.Broadening: return diff.permissionsBroadened;
        default: throw new Error(`Unrecognized approval level: ${requireApproval}`);
    }
}
function buildLogicalToPathMap(stack) {
    const map = {};
    for (const md of stack.findMetadataByType(cxschema.ArtifactMetadataEntryType.LOGICAL_ID)) {
        map[md.data] = md.path;
    }
    return map;
}
function logicalIdMapFromTemplate(template) {
    const ret = {};
    for (const [logicalId, resource] of Object.entries(template.Resources ?? {})) {
        const path = resource?.Metadata?.['aws:cdk:path'];
        if (path) {
            ret[logicalId] = path;
        }
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlmZi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRpZmYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkRBQTJEO0FBQzNELHdEQUF3RDtBQUV4RCwrQkFBK0I7QUFDL0IsdUNBQTJDO0FBRTNDOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWdCLGNBQWMsQ0FDNUIsV0FBZ0IsRUFDaEIsV0FBOEMsRUFDOUMsTUFBZSxFQUNmLE9BQWUsRUFDZixNQUE2QjtJQUU3QixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFbkUseURBQXlEO0lBQ3pELElBQUksb0JBQW9CLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLElBQUksSUFBSSxDQUFDLGVBQWUsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNuQyxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RyxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1FBQzFFLG9CQUFvQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxlQUFlLEdBQUcsV0FBVyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3ZGLElBQUksb0JBQW9CLEdBQUcsQ0FBQyxFQUFFO1lBQzVCLElBQUksR0FBRyxXQUFXLENBQUM7U0FDcEI7S0FDRjtJQUVELDhEQUE4RDtJQUM5RCxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDN0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM5QyxJQUFJLENBQUMs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QUM7QUFFRCxTQUFTLHdCQUF3QixDQUFDLFFBQWE7SUFDN0MsTUFBTSxHQUFHLEdBQTJCLEVBQUUsQ0FBQztJQUV2QyxLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQyxFQUFFO1FBQzVFLE1BQU0sSUFBSSxHQUFJLFFBQWdCLEVBQUUsUUFBUSxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDM0QsSUFBSSxJQUFJLEVBQUU7WUFDUixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQ3ZCO0tBQ0Y7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY2ZuRGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBwcmludCwgd2FybmluZyB9IGZyb20gJy4vbG9nZ2luZyc7XG5cbi8qKlxuICogUHJldHR5LXByaW50cyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGVtcGxhdGUgc3RhdGVzIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSBvbGRUZW1wbGF0ZSB0aGUgb2xkL2N1cnJlbnQgc3RhdGUgb2YgdGhlIHN0YWNrLlxuICogQHBhcmFtIG5ld1RlbXBsYXRlIHRoZSBuZXcvdGFyZ2V0IHN0YXRlIG9mIHRoZSBzdGFjay5cbiAqIEBwYXJhbSBzdHJpY3QgICAgICBkbyBub3QgZmlsdGVyIG91dCBBV1M6OkNESzo6TWV0YWRhdGFcbiAqIEBwYXJhbSBjb250ZXh0ICAgICBsaW5lcyBvZiBjb250ZXh0IHRvIHVzZSBpbiBhcmJpdHJhcnkgSlNPTiBkaWZmXG4gKlxuICogQHJldHVybnMgdGhlIGNvdW50IG9mIGRpZmZlcmVuY2VzIHRoYXQgd2VyZSByZW5kZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50U3RhY2tEaWZmKFxuICBvbGRUZW1wbGF0ZTogYW55LFxuICBuZXdUZW1wbGF0ZTogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICBzdHJpY3Q6IGJvb2xlYW4sXG4gIGNvbnRleHQ6IG51bWJlcixcbiAgc3RyZWFtPzogY2ZuRGlmZi5Gb3JtYXRTdHJlYW0pOiBudW1iZXIge1xuXG4gIGxldCBkaWZmID0gY2ZuRGlmZi5kaWZmVGVtcGxhdGUob2xkVGVtcGxhdGUsIG5ld1RlbXBsYXRlLnRlbXBsYXRlKTtcblxuICAvLyBkZXRlY3QgYW5kIGZpbHRlciBvdXQgbWFuZ2xlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGRpZmZcbiAgbGV0IGZpbHRlcmVkQ2hhbmdlc0NvdW50ID0gMDtcbiAgaWYgKGRpZmYuZGlmZmVyZW5jZUNvdW50ICYmICFzdHJpY3QpIHtcbiAgICBjb25zdCBtYW5nbGVkTmV3VGVtcGxhdGUgPSBKU09OLnBhcnNlKGNmbkRpZmYubWFuZ2xlTGlrZUNsb3VkRm9ybWF0aW9uKEpTT04uc3RyaW5naWZ5KG5ld1RlbXBsYXRlLnRlbXBsYXRlKSkpO1xuICAgIGNvbnN0IG1hbmdsZWREaWZmID0gY2ZuRGlmZi5kaWZmVGVtcGxhdGUob2xkVGVtcGxhdGUsIG1hbmdsZWROZXdUZW1wbGF0ZSk7XG4gICAgZmlsdGVyZWRDaGFuZ2VzQ291bnQgPSBNYXRoLm1heCgwLCBkaWZmLmRpZmZlcmVuY2VDb3VudCAtIG1hbmdsZWREaWZmLmRpZmZlcmVuY2VDb3VudCk7XG4gICAgaWYgKGZpbHRlcmVkQ2hhbmdlc0NvdW50ID4gMCkge1xuICAgICAgZGlmZiA9IG1hbmdsZWREaWZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgJ0FXUzo6Q0RLOjpNZXRhZGF0YScgcmVzb3VyY2VzIGZyb20gdGhlIHRlbXBsYXRlXG4gIGlmIChkaWZmLnJlc291cmNlcyAmJiAhc3RyaWN0KSB7XG4gICAgZGlmZi5yZXNvdXJjZXMgPSBkaWZmLnJlc291cmNlcy5maWx0ZXIoY2hhbmdlID0+IHtcbiAgICAgIGlmICghY2hhbmdlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICBpZiAoY2hhbmdlLm5ld1Jlc291cmNlVHlwZSA9PT0gJ0FXUzo6Q0RLOjpNZXRhZGF0YScpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpZiAoY2hhbmdlLm9sZFJlc291cmNlVHlwZSA9PT0gJ0FXUzo6Q0RLOjpNZXRhZGF0YScpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghZGlmZi5pc0VtcHR5KSB7XG4gICAgY2ZuRGlmZi5mb3JtYXREaWZmZXJlbmNlcyhzdHJlYW0gfHwgcHJvY2Vzcy5zdGRlcnIsIGRpZmYsIHtcbiAgICAgIC4uLmxvZ2ljYWxJZE1hcEZyb21UZW1wbGF0ZShvbGRUZW1wbGF0ZSksXG4gICAgICAuLi5idWlsZExvZ2ljYWxUb1BhdGhNYXAobmV3VGVtcGxhdGUpLFxuICAgIH0sIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHByaW50KGNoYWxrLmdyZWVuKCdUaGVyZSB3ZXJlIG5vIGRpZmZlcmVuY2VzJykpO1xuICB9XG4gIGlmIChmaWx0ZXJlZENoYW5nZXNDb3VudCA+IDApIHtcbiAgICBwcmludChjaGFsay55ZWxsb3coYE9taXR0ZWQgJHtmaWx0ZXJlZENoYW5nZXNDb3VudH0gY2hhbmdlcyBiZWNhdXNlIHRoZXkgYXJlIGxpa2VseSBtYW5nbGVkIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLiBVc2UgLS1zdHJpY3QgdG8gcHJpbnQgdGhlbS5gKSk7XG4gIH1cblxuICByZXR1cm4gZGlmZi5kaWZmZXJlbmNlQ291bnQ7XG59XG5cbmV4cG9ydCBlbnVtIFJlcXVpcmVBcHByb3ZhbCB7XG4gIE5ldmVyID0gJ25ldmVyJyxcblxuICBBbnlDaGFuZ2UgPSAnYW55LWNoYW5nZScsXG5cbiAgQnJvYWRlbmluZyA9ICdicm9hZGVuaW5nJ1xufVxuXG4vKipcbiAqIFByaW50IHRoZSBzZWN1cml0eSBjaGFuZ2VzIG9mIHRoaXMgZGlmZiwgaWYgdGhlIGNoYW5nZSBpcyBpbXBhY3RmdWwgZW5vdWdoIGFjY29yZGluZyB0byB0aGUgYXBwcm92YWwgbGV2ZWxcbiAqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYW5nZXMgYXJlIHByb21wdC13b3J0aHksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50U2VjdXJpdHlEaWZmKG9sZFRlbXBsYXRlOiBhbnksIG5ld1RlbXBsYXRlOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsIHJlcXVpcmVBcHByb3ZhbDogUmVxdWlyZUFwcHJvdmFsKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRpZmYgPSBjZm5EaWZmLmRpZmZUZW1wbGF0ZShvbGRUZW1wbGF0ZSwgbmV3VGVtcGxhdGUudGVtcGxhdGUpO1xuXG4gIGlmIChkaWZSZXF1aXJlc0FwcHJvdmFsKGRpZmYsIHJlcXVpcmVBcHByb3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHdhcm5pbmcoYFRoaXMgZGVwbG95bWVudCB3aWxsIG1ha2UgcG90ZW50aWFsbHkgc2Vuc2l0aXZlIGNoYW5nZXMgYWNjb3JkaW5nIHRvIHlvdXIgY3VycmVudCBzZWN1cml0eSBhcHByb3ZhbCBsZXZlbCAoLS1yZXF1aXJlLWFwcHJvdmFsICR7cmVxdWlyZUFwcHJvdmFsfSkuYCk7XG4gICAgd2FybmluZygnUGxlYXNlIGNvbmZpcm0geW91IGludGVuZCB0byBtYWtlIHRoZSBmb2xsb3dpbmcgbW9kaWZpY2F0aW9uczpcXG4nKTtcblxuICAgIGNmbkRpZmYuZm9ybWF0U2VjdXJpdHlDaGFuZ2VzKHByb2Nlc3Muc3Rkb3V0LCBkaWZmLCBidWlsZExvZ2ljYWxUb1BhdGhNYXAobmV3VGVtcGxhdGUpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgdGhlIGRpZmYgaGFzIHNlY3VyaXR5LWltcGFjdGluZyBjaGFuZ2VzIHRoYXQgbmVlZCBjb25maXJtYXRpb25cbiAqXG4gKiBUT0RPOiBGaWx0ZXIgdGhlIHNlY3VyaXR5IGltcGFjdCBkZXRlcm1pbmF0aW9uIGJhc2VkIG9mZiBvZiBhbiBlbnVtIHRoYXQgYWxsb3dzXG4gKiB1cyB0byBwaWNrIG1pbmltdW0gXCJzZXZlcml0aWVzXCIgdG8gYWxlcnQgb24uXG4gKi9cbmZ1bmN0aW9uIGRpZlJlcXVpcmVzQXBwcm92YWwoZGlmZjogY2ZuRGlmZi5UZW1wbGF0ZURpZmYsIHJlcXVpcmVBcHByb3ZhbDogUmVxdWlyZUFwcHJvdmFsKSB7XG4gIHN3aXRjaCAocmVxdWlyZUFwcHJvdmFsKSB7XG4gICAgY2FzZSBSZXF1aXJlQXBwcm92YWwuTmV2ZXI6IHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFJlcXVpcmVBcHByb3ZhbC5BbnlDaGFuZ2U6IHJldHVybiBkaWZmLnBlcm1pc3Npb25zQW55Q2hhbmdlcztcbiAgICBjYXNlIFJlcXVpcmVBcHByb3ZhbC5Ccm9hZGVuaW5nOiByZXR1cm4gZGlmZi5wZXJtaXNzaW9uc0Jyb2FkZW5lZDtcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBhcHByb3ZhbCBsZXZlbDogJHtyZXF1aXJlQXBwcm92YWx9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRMb2dpY2FsVG9QYXRoTWFwKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpIHtcbiAgY29uc3QgbWFwOiB7IFtpZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgZm9yIChjb25zdCBtZCBvZiBzdGFjay5maW5kTWV0YWRhdGFCeVR5cGUoY3hzY2hlbWEuQXJ0aWZhY3RNZXRhZGF0YUVudHJ5VHlwZS5MT0dJQ0FMX0lEKSkge1xuICAgIG1hcFttZC5kYXRhIGFzIHN0cmluZ10gPSBtZC5wYXRoO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGxvZ2ljYWxJZE1hcEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZTogYW55KSB7XG4gIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuXG4gIGZvciAoY29uc3QgW2xvZ2ljYWxJZCwgcmVzb3VyY2VdIG9mIE9iamVjdC5lbnRyaWVzKHRlbXBsYXRlLlJlc291cmNlcyA/PyB7fSkpIHtcbiAgICBjb25zdCBwYXRoID0gKHJlc291cmNlIGFzIGFueSk/Lk1ldGFkYXRhPy5bJ2F3czpjZGs6cGF0aCddO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICByZXRbbG9naWNhbElkXSA9IHBhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXX0=